#include "randstate.h"
#include "numtheory.h"
#include "ss.h"

//                              2
// Create public key n by  n = p  * q
// where p and q are large primes.
// Return nothing.
//
// p : variable for prime p
// q : variable for prime q
// n : variable for public key
// nbits : number of bits shared between p and q
// iters : iterations for Miller-Rabin prime algorithm
void ss_make_pub(mpz_t p, mpz_t q, mpz_t n, uint64_t nbits, uint64_t iters) {
    uint64_t pbits, qbits;
    mpz_t qt, pt;
    mpz_inits(qt, pt, NULL);
    // Determine bits to allocate for p such that
    // pbits in [nbits/5, (2*nbits)/5).
    // The rest of nbits (accounting for p squared)
    // goes to q.
    do {
        pbits = random() % ((2 * nbits) / 5);
    } while (pbits < nbits / 5);
    qbits = nbits - (2 * pbits);
    // Make the primes. Ensure p doesn't divide q-1 and the inverse.
    do {
        make_prime(p, pbits, iters);
        make_prime(q, qbits, iters);
        mpz_sub_ui(pt, p, 1);
        mpz_sub_ui(qt, q, 1);
        mpz_mod(pt, pt, q);
        mpz_mod(qt, qt, p);
    } while (!mpz_cmp_ui(pt, 0) && !mpz_cmp_ui(qt, 0));
    mpz_mul(pt, p, p);
    mpz_mul(n, pt, q);
    mpz_clears(qt, pt, NULL);
}

// Create private key d such that  d = inverse of n mod λ(pq)
// Returns nothing.
//
// d : variable for private key d
// pq : product of primes generated by make_pub()
// p : prime p
// q : prime q
void ss_make_priv(mpz_t d, mpz_t pq, const mpz_t p, const mpz_t q) {
    mpz_t pt, qt, prod, g;
    mpz_init_set(qt, q);
    mpz_init_set(pt, p);
    mpz_inits(prod, g, NULL);
    // λ(pq) = lcm(p-1,q-1) = (p-1) (q-1) / gcd(p-1,q-1)
    mpz_sub_ui(pt, pt, 1);
    mpz_sub_ui(qt, qt, 1);
    mpz_mul(prod, pt, qt);
    gcd(g, pt, qt);
    mpz_tdiv_q(prod, prod, g);
    mpz_mul(pq, p, q);
    mpz_mul(pq, p, pq);
    mod_inverse(d, pq, prod);
    mpz_mul(pq, p, q);
    mpz_clears(qt, pt, g, prod, NULL);
}

// Write public key n and user's name to pbfile.
// Return nothing.
//
// n : public key
// username : username string
// pbfile : file pointer to write to
void ss_write_pub(const mpz_t n, const char username[], FILE *pbfile) {
    gmp_fprintf(pbfile, "%Zx\n%s\n", n, username);
}

// Write private key d and also pq to pvfile.
//Return nothing.
//
// pq : product of primes p and q
// d : private key
// pvfile : file pointer to print to
void ss_write_priv(const mpz_t pq, const mpz_t d, FILE *pvfile) {
    gmp_fprintf(pvfile, "%Zx\n%Zx\n", pq, d);
}

// Read username and public key from pbfile.
// Returns nothing.
//
// n : public key
// username : username string
// pbfile : public file pointer
void ss_read_pub(mpz_t n, char username[], FILE *pbfile) {
    gmp_fscanf(pbfile, "%Zx\n%s\n", n, username);
}

// Read private key and pq from pvfile.
// Returns nothing.
//
// pq : product of primes p and q
// d : private key
// pvfile : private file pointer
void ss_read_priv(mpz_t pq, mpz_t d, FILE *pbfile) {
    gmp_fscanf(pbfile, "%Zx\n%Zx\n", pq, d);
}

// Encrypt message m into ciphertext c using public key n.
// Return nothing.
//
// c : ciphertext
// m : raw message
// n : public key
void ss_encrypt(mpz_t c, const mpz_t m, const mpz_t n) {
    pow_mod(c, m, n, n);
}

// Read infile, encrypt message and print ciphertext to outfile.
// Returns nothing.
//
// infile : file pointer to input file
// outfile : file pointer to write file
// n : public key
void ss_encrypt_file(FILE *infile, FILE *outfile, const mpz_t n) {
    size_t k;
    int ch;
    uint8_t *buffer = NULL;
    mpz_t temp, c, m;
    mpz_inits(temp, c, m, NULL);
    // Assign k to bytes per block:
    //
    //              1/2
    // k = ( log2( n   ) - 1 ) / 8
    //
    mpz_sqrt(temp, n);
    k = (mpz_sizeinbase(temp, 2) - 1) / 8;
    buffer = calloc(k, sizeof(uint8_t));
    // Prepend buffer.
    buffer[0] = 0xFF;
    // Encrypt each character from infile. When the limit,
    // k - 1, is reached write the buffer.
    for (size_t i = 1; (ch = fgetc(infile)) != EOF; i++) {
        buffer[i] = ch;
        if (i == k - 1) {
            // change k to i = 1 again
            mpz_import(m, k, 1, sizeof(uint8_t), 1, 0, buffer);
            ss_encrypt(c, m, n);
            gmp_fprintf(outfile, "%Zx\n", c);
            i = 1;
            for (uint64_t j = 1; j < k; j++) {
                buffer[j] = 0x00;
            }
        }
    }
    // Write any remaining data from buffer.
    mpz_import(m, k, 1, sizeof(uint8_t), 1, 0, buffer);
    ss_encrypt(c, m, n);
    gmp_fprintf(outfile, "%Zx\n", c);
    mpz_clears(temp, c, m, NULL);
    free(buffer);
}

// Decrypt ciphertext c to raw message m using private key d and pq.
// Returns nothing.
//
// m : raw message
// c : ciphertext
// d : private key
// pq : product of primes p and q
void ss_decrypt(mpz_t m, const mpz_t c, const mpz_t d, const mpz_t pq) {
    pow_mod(m, c, d, pq);
}

// Read from infile, decrypt to raw message, then write to outfile.
// Returns nothing.
//
// infile : file pointer to input file
// outfile : file pointer to ouput file
// pq : product of p and q
// d : private key
void ss_decrypt_file(FILE *infile, FILE *outfile, const mpz_t pq, const mpz_t d) {
    size_t k, j;
    uint8_t *buffer = NULL;
    mpz_t c, m;
    mpz_inits(c, m, NULL);
    // Make block size greater than block size in
    // encryption.
    k = (mpz_sizeinbase(pq, 2) - 1) / 8;
    buffer = calloc(k, sizeof(uint8_t));
    // Read line from infile, decrypt, then print each character
    // to outfile.
    while ((gmp_fscanf(infile, "%Zx\n", c)) != EOF) {
        ss_decrypt(m, c, d, pq);
        mpz_export(buffer, &j, 1, sizeof(uint8_t), 1, 0, m);
        for (size_t i = 1; i < j; i++) {
            fputc(buffer[i], outfile);
        }
    }
    mpz_clears(c, m, NULL);
    free(buffer);
}
